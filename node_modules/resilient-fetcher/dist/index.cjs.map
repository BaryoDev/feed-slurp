{"version":3,"sources":["../src/index.ts"],"sourcesContent":["export interface ResilientOptions {\n    /** Number of retry attempts (default: 3) */\n    retries?: number;\n    /** Delay between retries in ms (default: 1000) */\n    retryDelay?: number;\n    /** Request timeout in ms (default: 5000) */\n    timeout?: number;\n    /** Backoff strategy: 'fixed' | 'exponential' (default: 'fixed') */\n    backoff?: 'fixed' | 'exponential';\n    /** Custom condition to determine if request should be retried */\n    retryOn?: (error: Error | null, response: Response | null) => boolean;\n    /** Request interceptor */\n    onRequest?: (url: string, options: RequestInit) => RequestInit | Promise<RequestInit>;\n    /** Response interceptor */\n    onResponse?: (response: Response) => Response | Promise<Response>;\n    /** Error handler */\n    onError?: (error: Error) => void;\n}\n\n/**\n * Calculates delay with optional exponential backoff and jitter.\n */\nfunction calculateDelay(attempt: number, baseDelay: number, backoff: 'fixed' | 'exponential'): number {\n    if (backoff === 'exponential') {\n        const exponentialDelay = baseDelay * Math.pow(2, attempt - 1);\n        const jitter = Math.random() * 0.3 * exponentialDelay; // 0-30% jitter\n        return exponentialDelay + jitter;\n    }\n    return baseDelay;\n}\n\n/**\n * Default retry condition: retry on network errors and 5xx responses.\n */\nconst defaultRetryOn = (_error: Error | null, response: Response | null): boolean => {\n    if (!response) return true; // Network error\n    return response.status >= 500;\n};\n\n/**\n * A resilient wrapper around the native fetch API with retry and timeout capabilities.\n *\n * @example\n * const response = await resilientFetch('https://api.example.com/data');\n * \n * const response = await resilientFetch('https://api.example.com/data', {\n *   retries: 3,\n *   timeout: 10000,\n *   backoff: 'exponential'\n * });\n */\nexport async function resilientFetch(\n    url: string | URL | Request,\n    options: RequestInit & ResilientOptions = {}\n): Promise<Response> {\n    const {\n        retries = 3,\n        retryDelay = 1000,\n        timeout = 5000,\n        backoff = 'fixed',\n        retryOn = defaultRetryOn,\n        onRequest,\n        onResponse,\n        onError,\n        ...fetchOptions\n    } = options;\n\n    let attempt = 0;\n    let finalUrl = url.toString();\n    let finalOptions: RequestInit = fetchOptions;\n\n    // Apply request interceptor\n    if (onRequest) {\n        finalOptions = await onRequest(finalUrl, fetchOptions);\n    }\n\n    while (true) {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n        try {\n            const response = await fetch(finalUrl, {\n                ...finalOptions,\n                signal: controller.signal\n            });\n\n            clearTimeout(timeoutId);\n\n            if (!response.ok) {\n                // Check if we should retry\n                if (attempt < retries && retryOn(null, response)) {\n                    attempt++;\n                    const delay = calculateDelay(attempt, retryDelay, backoff);\n                    await new Promise(resolve => setTimeout(resolve, delay));\n                    continue;\n                }\n                throw new Error(`Request failed with status ${response.status}`);\n            }\n\n            // Apply response interceptor\n            if (onResponse) {\n                return await onResponse(response);\n            }\n\n            return response;\n        } catch (error) {\n            clearTimeout(timeoutId);\n            attempt++;\n\n            const isAbort = (error as Error).name === 'AbortError';\n            const err = isAbort ? new Error('Request timed out') : error as Error;\n\n            // Call error handler\n            if (onError) {\n                onError(err);\n            }\n\n            // Check if we should retry\n            if (attempt <= retries && retryOn(err, null)) {\n                const delay = calculateDelay(attempt, retryDelay, backoff);\n                await new Promise(resolve => setTimeout(resolve, delay));\n                continue;\n            }\n\n            throw err;\n        }\n    }\n}\n\nexport default resilientFetch;\n"],"mappings":"yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,EAAA,mBAAAC,IAAA,eAAAC,EAAAJ,GAsBA,SAASK,EAAeC,EAAiBC,EAAmBC,EAA0C,CAClG,GAAIA,IAAY,cAAe,CAC3B,IAAMC,EAAmBF,EAAY,KAAK,IAAI,EAAGD,EAAU,CAAC,EACtDI,EAAS,KAAK,OAAO,EAAI,GAAMD,EACrC,OAAOA,EAAmBC,CAC9B,CACA,OAAOH,CACX,CAKA,IAAMI,EAAiB,CAACC,EAAsBC,IACrCA,EACEA,EAAS,QAAU,IADJ,GAgB1B,eAAsBV,EAClBW,EACAC,EAA0C,CAAC,EAC1B,CACjB,GAAM,CACF,QAAAC,EAAU,EACV,WAAAC,EAAa,IACb,QAAAC,EAAU,IACV,QAAAV,EAAU,QACV,QAAAW,EAAUR,EACV,UAAAS,EACA,WAAAC,EACA,QAAAC,EACA,GAAGC,CACP,EAAIR,EAEAT,EAAU,EACVkB,EAAWV,EAAI,SAAS,EACxBW,EAA4BF,EAOhC,IAJIH,IACAK,EAAe,MAAML,EAAUI,EAAUD,CAAY,KAG5C,CACT,IAAMG,EAAa,IAAI,gBACjBC,EAAY,WAAW,IAAMD,EAAW,MAAM,EAAGR,CAAO,EAE9D,GAAI,CACA,IAAML,EAAW,MAAM,MAAMW,EAAU,CACnC,GAAGC,EACH,OAAQC,EAAW,MACvB,CAAC,EAID,GAFA,aAAaC,CAAS,EAElB,CAACd,EAAS,GAAI,CAEd,GAAIP,EAAUU,GAAWG,EAAQ,KAAMN,CAAQ,EAAG,CAC9CP,IACA,IAAMsB,EAAQvB,EAAeC,EAASW,EAAYT,CAAO,EACzD,MAAM,IAAI,QAAQqB,GAAW,WAAWA,EAASD,CAAK,CAAC,EACvD,QACJ,CACA,MAAM,IAAI,MAAM,8BAA8Bf,EAAS,MAAM,EAAE,CACnE,CAGA,OAAIQ,EACO,MAAMA,EAAWR,CAAQ,EAG7BA,CACX,OAASiB,EAAO,CACZ,aAAaH,CAAS,EACtBrB,IAGA,IAAMyB,EADWD,EAAgB,OAAS,aACpB,IAAI,MAAM,mBAAmB,EAAIA,EAQvD,GALIR,GACAA,EAAQS,CAAG,EAIXzB,GAAWU,GAAWG,EAAQY,EAAK,IAAI,EAAG,CAC1C,IAAMH,EAAQvB,EAAeC,EAASW,EAAYT,CAAO,EACzD,MAAM,IAAI,QAAQqB,GAAW,WAAWA,EAASD,CAAK,CAAC,EACvD,QACJ,CAEA,MAAMG,CACV,CACJ,CACJ,CAEA,IAAO7B,EAAQC","names":["index_exports","__export","index_default","resilientFetch","__toCommonJS","calculateDelay","attempt","baseDelay","backoff","exponentialDelay","jitter","defaultRetryOn","_error","response","url","options","retries","retryDelay","timeout","retryOn","onRequest","onResponse","onError","fetchOptions","finalUrl","finalOptions","controller","timeoutId","delay","resolve","error","err"]}